#include "config.h"

void main() {

//	일반 변수는 값(상수)을 기억하지만 포인터 변수(이하 포인터)는 일반 변수 또는 배열이 메모리에 생성된 주소값을
//	기억한다.
	int a = 100;		// 일반 변수
//	포인터 선언시 포인터의 자료형은 포인터에 주소를 저장할 변수 또는 배열의 자료형을 적어준다.
	int *p1;			// 포인터, 포인터 선언시 변수명 앞에 "*"을 붙인다.

//	p1 = 100;			// 포인터에 상수를 넣으려 했으므로 에러가 발생된다.
//	p1 = a;				// 포인터에 변수에 저장된 값(상수)를 넣으려 했으므로 에러가 발생된다.
//	p1 = NULL;			// 포인터를 NULL로 초기화 했으므로 에러가 발생되지 않는다.
//	"&"가 이항 연산자로 사용되면 비트끼리 AND 연산을 하고 단항 연산자로 사용되면 번지 연산자가 된다.
//	"&"를 변수앞에 붙여주면 그 변수가 메모리에 생성된 위치(주소) 값을 얻어온다.
	p1 = &a;			// 포인터에 변수 a가 생성된 메모리의 주소를 넣어준다.

	cout << "변수 a에 저장된 값 : " << a << endl;
	cout << "변수 a가 생성된 주소 : " << &a << endl;
	cout << "포인터 p1에 저장된 값 : " << p1 << endl;
//	"*"가 이항 연산자로 사용되면 곱셈을 하고 단항 연산자로 사용되면 참조 연산자가 된다.
//	"*"을 변수 선언시 붙여주면 포인터임을 의미하고 그 이외의 경우에는 포인터에 저장된 주소에 저장된 실제 값을
//	얻어온다.
	cout << "포인터 p1이 참조하는 값 : " << *p1 << endl;
	cout << "==========================================================" << endl;

	int b[] = {100, 200, 300, 400, 500};		// 정적 배열
	int *p2;

	cout << "배열 b가 메모리에 생성된 주소 : " << b << endl;
	cout << "배열 b가 메모리에 생성된 주소 : " << &b[0] << endl;

//	배열의 이름은 그 배열이 메모리에 생성된 시작 주소를 알고있는 번지 상수이다. 즉, 배열명은 주소다.
//	배열 요소는 일반 변수와 똑같이 취급된다.
	p2 = b;				// 포인터에 배열명을 넣을 경우는 "&"를 붙이지 않는다.
	p2 = &b[0];			// 포인터에 배열 요소를 넣을 경우는 일반 변수와 같이 "&"를 붙여야 한다.

	cout << "포인터 p2에 저장된 값 : " << p2 << endl;
	cout << "포인터 p2가 참조하는 값 : " << *p2 << endl;
	cout << "==========================================================" << endl;

	for(int i=0 ; i<5 ; i++) {
		cout << "b[" << i << "]에 저장된 값 : " << b[i] << endl;
	}
	cout << "==========================================================" << endl;

	for(int i=0 ; i<5 ; i++) {
		cout << "b[" << i << "]의 주소 : " << &b[i] << endl;
	}
	cout << "==========================================================" << endl;

	for(int i=0 ; i<5 ; i++) {
		cout << "p2[" << i << "]에 저장된 값 : " << p2[i] << endl;
	}
	cout << "==========================================================" << endl;

	for(int i=0 ; i<5 ; i++) {
//		포인터에는 +, - 연산만 가능하다.
//		포인터에 1을 더하면 단순히 숫자 1이 더해지는 것이 아니고 포인터 선언시 붙여준 자료형의 크기만큼 증가한다.
		cout << "p2 + " << i << "의 주소 : " << p2 + i << endl;
	}
	cout << "==========================================================" << endl;

	for(int i=0 ; i<5 ; i++) {
		cout << "*(p2 + " << i << ")이 참조하는 값 : " << *(p2 + i) << endl;
	}
	cout << "==========================================================" << endl;

	int *c = (int *)malloc(sizeof(int) * 5);
	int *d = new int[5];

	cout << "정적 할당된 배열 b가 차지하는 용량 : " << sizeof(b) << endl;
	cout << "동적 할당된 배열 c가 차지하는 용량 : " << sizeof(c) << endl;
	cout << "동적 할당된 배열 d가 차지하는 용량 : " << sizeof(d) << endl;

	free(c);
	delete[] d;

}