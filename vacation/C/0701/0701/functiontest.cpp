#include "config.h"

//	리턴타입 함수명([인수, ...]) {				// 함수의 머리
//		함수가 실행할 문장;						// {} 블록을 함수의 몸체라 한다.
//		...;
//		[return 값;]							// return이 생략되면 리턴 타입에 "void"라고 적는다.
//	}
//	함수는 return을 만나거나 함수의 "}"를 만나면 함수를 호출한 곳으로 되돌아간다.

int total() {
	int sum = 0;
	for(int i=1 ; i<=100 ; i++) {
		sum += i;
	}
	return sum;
}

//	하나의 파일에 같은 이름의 함수가 여러개 나올수 있다. 이를 함수 오버로딩이라 부른다.
//	같은 이름의 함수가 여러개 존재할 경우 C++ 컴파일러는 함수 인수의 개수, 인수의 개수도 같다면 인수의 데이터 타입으로
//	함수를 구별한다.

int total(int n) {
	int sum = 0;
	for(int i=1 ; i<=n ; i++) {
		sum += i;
	}
	n = 10;												// 가인수 값 변경
	cout << "가인수 n에 저장된 값 : " << n << endl;
	return sum;
}

int total(int n, int m) {
	int sum = 0;
	for(int i=n ; i<=m ; i++) {
		sum += i;
	}
	return sum;
}

void main() {

	cout << "1~100의 합계 : " << total() << endl;		// total() 함수를 호출

	int n;
	cout << "숫자를 입력하세요 : ";
	cin >> n;
//	함수를 호출하는 인수를 실인수라 하고 호출 받는 인수를 가인수라 부른다.
//	total(n) 함수를 호출하면 실인수 n에 저장된 값을 복사해서 가인수에 넣어준다. 이런 매개변수 전달 방식을
//	값에 의한 호출(call by value)라 부른다.
//	call by value의 특징
//	실인수와 가인수의 이름은 같던 다르던 아무런 상관이 없지만 데이터 타입은 반드시 같아야 한다.
//	실인수와 가인수는 독립된 기억공간이 할당되므로 가인수 값이 변경되더라도 실인수 값은 변경되지 않는다.
//	함수로 여러개의 인수를 전달할 수 있지만 결과는 무조건 1개만 받아올 수 있다.
//	실인수와 가인수가 독립된 기억공간이 할당되므로 side effect(부작용) 현상이 발생되지 않는다.
	cout << "1~" << n << "의 합계 : " << total(n) << endl;				// total(n) 함수를 호출
	cout << "실인수 n에 저장된 값 : " << n << endl;

	int m;
	cout << "숫자 2개를 입력하세요 : ";
	cin >> n >> m;
	cout << n << "~" << m << "의 합계 : " << total(n, m) << endl;		// total(n, m) 함수를 호출

}